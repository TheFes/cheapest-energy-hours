blueprint:
  name: Cheapest Energy Hours price sensor
  description: "# Cheapest Energy Hours price sensor
    
    This blueprint creates a sensor with a `prices` attribute which contains the prices
    from yesterday, today and tomorrow (if available). These prices can be used in the
    Cheapest Energy Hours macro.
    
    
    The blueprint can be used with the following integrations
    
    - Easy Energy
    
    - Energy Zero
    
    - Nordpool
    
    - Tibber
    
    
    The following inputs can be used in this blueprint:
    
    |input|default|description|
    
    |---|---|---|
    
    |`source`|`null`|The integration to be used as source, possible values are
    `easyenergy`, `energyzero`, `nordpool`, `tibber`|
    
    |`entity_id`|`sensor.cheapest_energy_hour_prices`|The entity id to be used for the template
    sensor|
    
    |`config_entry`|`null`|Required for Easy Energy, Energy Zero and Nordpool. To find it the
    easiest method is to go to Developer tools > Actions and use one of the actions provided
    by the integration in GUI mode, select the config entry and then switch to YAML mode|
    
    |`price_period`|`source`|The period in minutes to be used for the prices stored
    in the sensor. Possible values are `15`, `60` and `source`. This can be used to create
    hourly prices when the intgration provides prices per 15 minutes. By default it will use
    the same period as used in the source integration.|
    
    |`include_vat`|`false`|Only used for Easy Energy and Energy Zero. There is an option in
    the action to retreive the prices to include VAT. By default this is set to `false` as for
    Energy Zero this will result in prices rounded to 2 decimals. The `add_vat` input can be
    used to add VAT as well, but keep the precision.|
    
    |`add_vat`|`0`|VAT perecentage which will be added to the prices|
    
    |`add_fixed`|`0`|Can be used to add a fixed value to the prices. If you use the Nordpool
    integration you can use this to add the fixed uplift charged by your energy provider.|
    
    |`price_factor`|`1`|All prices will be multiplied with this value. This can be used for the
    Nordpool integration as prices are provided in MWh. You can use `0.001` to convert to kWh|
    
    
    Example:
    
    ```yaml
    
    template:
    
      - use_blueprint:
    
      path: TheFes/energy_price_sensor.yaml
    
      input:
    
        source: nordpool
    
        config_entry: 01K7YVVKK4RJ9SA25SZVS0AR19
    
        entity_id: sensor.nordpool_ceh_prices
    
        price_factor: 0.001
    
        add_vat: 21
    
        add_fixed: 0.0023
    
      name: Nordpool Cheapest Energy Hours
    
      unique_id: 881b6558-26c6-44bb-81c5-d86c05451bd4
    
    ```"
  author: TheFes
  source_url: https://github.com/TheFes/HA-configuration/blob/main/blueprints/template/TheFes/nordpool_hourly.yaml
  domain: template
  input:
    source:
      name: Source integration
      description: The source integration used to provide the data
      selector:
        select:
          options:
            - label: EasyEnergy
              value: easyenergy
            - label: EnergyZero
              value: energyzero
            - label: NordPool
              value: nordpool
            - label: Tibber
              value: tibber
    entity_id:
      name: Entity id for template sensor
      description: The entity_id which will be used for the template sensor created using this blueprint
      selector:
        text:
          multiple: false
          multiline: false
      default: sensor.cheapest_energy_hour_prices
    config_entry:
      name: The config entry id for the integration.
      description: This is not required for Tibber, but for all other source integrations it is a required field
      selector:
        config_entry:
      default: null
    price_period:
      name: Price period in minutes
      description: >
        The price period used for the output of the price data. This can be used to force the output to a different period
        compared to the source integration. By default the price period as provided by the source will be used.
      selector:
        select:
          options:
            - label: 60 minutes
              value: 60
            - label: 15 minutes
              value: 15
            - label: Use source
              value: source
      default: source
    include_vat:
      name: Include VAT in prices
      description:
        Only used for EasyEnergy and EnergyZero. Note that for EnergyZero this the prices will be rounded to 2
        decimal precision if include VAT is enabled.
      default: false
    add_vat:
      name: VAT % to add to the prices
      description: Set a percentage here if you want to add VAT to the prices provided by the source integration
      selector:
        number:
          min: 0
          max: 100
          step: "any"
          unit_of_measurement: "%"
          mode: "box"
      default: 0
    add_fixed:
      name:
        Fixed value to be added to prices. Can be used to e.g. add a fixed price for your energy provided in
        case you use Nordpool as the source. This fixed value should already include VAT if applicable.
      selector:
        number:
          step: "any"
          mode: "box"
      default: 0
    price_factor:
      name: Price Factor
      description:
        Value which will be used to multiply the prices with. If the source integration e.g. provides the prices
        in cents, but you want them in EUR, you can use 0.01 as price factor.
      selector:
        number:
          step: "any"
          mode: "box"
      default: 1

variables:
  entity_id: !input entity_id
  price_period: !input price_period
  source: !input source
  include_vat: !input include_vat
  price_factor: !input price_factor
  add_vat: !input add_vat
  add_fixed: !input add_fixed
  old_prices: "{{ state_attr(entity_id, 'prices') | default([], true) }}"
  min_values: >
    {{
      23 if old_prices | count < 2
      else
        23 * (3600 / (old_prices[1].start | as_datetime - old_prices[0].start | as_datetime).seconds)
    }}
  includes:
    today: >
      {{ old_prices 
        | selectattr('start', 'search', now().date().isoformat())
        | list
        | count >= min_values }}
    tomorrow: >
      {{ old_prices 
        | selectattr('start', 'search', (now() + timedelta(days=1)).date().isoformat())
        | list
        | count >= min_values }}
  should_fetch: >
    {{ not includes.today or (now() > today_at('13:00') and not includes.tomorrow) }}
  mapping:
    easyenergy:
      time_key: timestamp
      value_key: price
    energyzero:
      time_key: timestamp
      value_key: price
    nordpool:
      time_key: start
      value_key: price
    tibber:
      time_key: start_time
      value_key: price

triggers:
  - alias: Triggers every 15 minutes
    trigger: time_pattern
    minutes: "/15"
  - alias: Triggers on home assistant startup
    trigger: homeassistant
    event: start
  - alias: Custom event to update prices
    trigger: event
    event_type: update_ceh_prices
    id: event

actions:
  - alias: "Fetch new prices if needed"
    if: "{{ trigger.id == 'event' or should_fetch }}"
    then:
      - alias: Short delay to avoid everyone calling the API at the same time
        delay:
          seconds: "{{ range(0, 15) | random }}"
      - choose:
          - conditions: "{{ source in ['easyenergy', 'energyzero'] }}"
            sequence:
              - alias: Collects the price information and stores this in a response variable
                action: >
                  {{
                    'easyenergy.get_energy_usage_prices'
                    if source == 'easyenergy'
                    else 'energyzero.get_energy_prices'
                  }}
                data:
                  incl_vat: "{{ include_vat }}"
                  config_entry: !input config_entry
                  start: "{{ today_at() - timedelta(days=1) }}"
                  end: "{{ today_at() + timedelta(days=2) }}"
                response_variable: prices
              - variables:
                  prices: "{{ prices.prices if prices is defined else [] }}"
          - conditions: "{{ source == 'tibber' }}"
            sequence:
              - alias: Short delay to avoid everyone calling the API at the same time
                delay:
                  seconds: "{{ range(0, 15) | random }}"
              - alias: "Fetch the prices for yesterday, today and tomorrow"
                action: tibber.get_prices
                data:
                  start: "{{ (today_at('00:00') - timedelta(days=1)).strftime('%Y-%m-%d %H:%M:%S') }}"
                  end: "{{ (today_at('00:00') + timedelta(days=2)).strftime('%Y-%m-%d %H:%M:%S') }}"
                response_variable: prices
              - variables:
                  prices: "{{ (prices.prices.values() | first | default([])) if response is defined else [] }}"
          - conditions: "{{ source == 'nordpool' }}"
            sequence:
              - if: "{{ price_period == 'source' }}"
                then:
                  - action: nordpool.get_prices_for_date
                    data:
                      config_entry: !input config_entry
                      date: "{{ now().date() - timedelta(days=1) }}"
                    response_variable: yesterday
                  - action: nordpool.get_prices_for_date
                    data:
                      config_entry: !input config_entry
                      date: "{{ now().date() }}"
                    response_variable: today
                  - action: nordpool.get_prices_for_date
                    data:
                      config_entry: !input config_entry
                      date: "{{ now().date() + timedelta(days=1) }}"
                    response_variable: tomorrow
                else:
                  - action: nordpool.get_price_indices_for_date
                    data:
                      config_entry: !input config_entry
                      date: "{{ now().date() - timedelta(days=1) }}"
                      resolution: "{{ time_period | int }}"
                    response_variable: yesterday
                  - action: nordpool.get_price_indices_for_date
                    data:
                      config_entry: !input config_entry
                      date: "{{ now().date() }}"
                      resolution: "{{ time_period | int }}"
                    response_variable: today
                  - action: nordpool.get_price_indices_for_date
                    data:
                      config_entry: !input config_entry
                      date: "{{ now().date() + timedelta(days=1) }}"
                      resolution: "{{ time_period | int }}"
                    response_variable: tomorrow
              - variables:
                  prices: "{{ today.values() | first + tomorrow.values() | first }}"
      - alias: Update result to generic format and apply price_period if needed
        variables:
          prices: >
            {% set time_key = mapping[source].time_key %}
            {% set value_key = mapping[source].value_key %}
            {% set ns = namespace(prices=[], processed=false) %}
            {% for price in prices %}
              {% set ns.processed = false %}
              {% if price_period != 'source' %}
                {% if not loop.last %}
                  {% set source_period = (loop.nextitem[time_key] | as_datetime - price[time_key] | as_datetime).seconds // 60 %}
                {% else %}
                  {% set source_period = (price[time_key] | as_datetime - loop.previtem[time_key] | as_datetime).seconds // 60 %}
                {% endif %}
                {%- if price_period != 'source' and source_period > price_period | int %}
                  {% set factor = source_period // price_period %}
                  {% set t = price[time_key] | as_datetime | as_local %}
                  {% set p = price[value_key] * price_factor * (1 + add_vat / 100) + add_fixed %}
                  {% for i in range(factor) %}
                      {% set ns.prices = ns.prices + [dict(start=(t+timedelta(hours=(1/factor)*loop.index)).isoformat(), price=p | round(5))] %}
                  {% endfor %}
                {%- elif price_period != 'source' and source_period < price_period | int %}
                  {% set factor = price_period // source_period %}
                  {% if loop.index % factor == 0 %}
                    {% set t = (price[time_key] | as_datetime | as_local).isoformat() %}
                    {% set avg = prices[loop.index:loop.index+factor] | map(attribute=value_key) | list | average %}
                    {% set p = (avg * price_factor * (1 + add_vat / 100) + add_fixed) | round(5) %}
                    {% set ns.prices = ns.prices + [dict(start=t, price=p | round(5))] %}
                  {% endif %}
                  {% set ns.processed = true %}
                {% endif %}
              {% endif %}
              {% if not ns.processed %}
                {% set t = (price[time_key] | as_datetime | as_local).isoformat() %}
                {% set p = price[value_key] * price_factor * (1 + add_vat / 100) + add_fixed %}
                {% set ns.prices = ns.prices + [dict(start=t, price=p | round(5))] %}
              {%- endif %}
            {% endfor %}
            {{ ns.prices }}
  - alias: "Set variables to be used in sensor"
    variables:
      updated_prices: "{{ prices | default(false) or old_prices }}"
      fetch_time: "{{ now() if prices is defined and prices else state_attr(entity_id, 'last_fetch_time') }}"
      prices_today: >
        {{
          updated_prices
            | selectattr('start', 'search', now().date().isoformat())
            | map(attribute='price')
            | list
        }}

sensor:
  default_entity_id: !input entity_id
  icon: mdi:currency-eur
  unit_of_measurement: EUR/kWh
  state_class: measurement
  state: >
    {% set price = updated_prices | map(attribute='price') | list %}
    {% set time = updated_prices | map(attribute='start') | map('as_datetime') | list %}
    {{ zip(price, time) | selectattr('1', '<=', now()) | map(attribute='0') | list | last }}
  attributes:
    prices: "{{ updated_prices }}"
    last_fetch_time: "{{ fetch_time }}"
  availability: "{{ prices_today | count >= min_values }}"
